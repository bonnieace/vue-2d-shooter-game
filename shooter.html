<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vue CDN ‚Äî 2D Canvas Shooter (Fullscreen)</title>
  <style>
    :root{--bg:#0b1020;--panel:#0f1724;--accent:#4fd1c5;--danger:#ff6b6b}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#071023 0%, #071428 60%);color:#dbeafe;overflow:hidden}
    .gameover-img {
      width:120px;
      height:auto;
      display:block;
      margin: 0 auto 12px auto;
      filter: drop-shadow(0 6px 20px rgba(0,0,0,0.6));
    }
    .gameover-stats .small { text-align:center; margin:6px 0; }

    /* Pause Menu Styles */
    .pause-menu {
      display:flex;
      gap:16px;
      align-items:flex-start;
      height:100vh;
      padding:18px;
    }
    
    .game-preview {
      position:relative;
      flex:1;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    
    .preview-canvas {
      background:radial-gradient(ellipse at center,#071428 0%, #020612 60%);
      border-radius:12px;
      box-shadow:0 6px 30px rgba(2,6,15,0.7);
      max-width:100%;
      height:auto;
      opacity:0.3;
    }
    
    .play-overlay {
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      background:rgba(7,10,20,0.8);
      backdrop-filter:blur(8px);
      border-radius:12px;
    }
    
    .play-button {
      background:linear-gradient(135deg, var(--accent), #60a5fa);
      border:none;
      color:white;
      padding:16px 32px;
      border-radius:12px;
      font-size:18px;
      font-weight:700;
      cursor:pointer;
      transition:transform 0.2s, box-shadow 0.2s;
      box-shadow:0 4px 20px rgba(79,209,197,0.3);
    }
    
    .play-button:hover {
      transform:translateY(-2px);
      box-shadow:0 6px 25px rgba(79,209,197,0.4);
    }
    
    .settings-panel {
      width:320px;
      background:var(--panel);
      padding:20px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.03);
      height:fit-content;
    }
    
    /* Fullscreen Game Styles */
    .fullscreen-game {
      position:fixed;
      top:0;
      left:0;
      width:100vw;
      height:100vh;
      background:#000;
      z-index:1000;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    
    .game-canvas {
      width:100vw;
      height:100vh;
      object-fit:contain;
      background:radial-gradient(ellipse at center,#071428 0%, #020612 60%);
    }
    
    /* In-game HUD */
    .game-hud {
      position:absolute;
      left:20px;
      top:20px;
      background:rgba(7,10,20,0.8);
      backdrop-filter:blur(8px);
      padding:12px 16px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.1);
      z-index:1001;
    }
    
    .hud-row {
      display:flex;
      align-items:center;
      gap:16px;
      margin-bottom:8px;
    }
    
    .hud-row:last-child {
      margin-bottom:0;
    }
    
    .score-display {
      font-weight:700;
      font-size:18px;
    }
    
    .health-bar {
      width:200px;
      height:8px;
      background:rgba(255,255,255,0.1);
      border-radius:4px;
      overflow:hidden;
    }
    
    .health-fill {
      height:100%;
      background:linear-gradient(90deg, var(--accent), #60a5fa);
      transition:width 0.3s ease;
    }
    
    .weapon-info {
      font-size:14px;
      opacity:0.9;
    }
    
    /* Pause overlay in fullscreen */
    .pause-overlay {
      position:absolute;
      inset:0;
      background:rgba(0,0,0,0.8);
      backdrop-filter:blur(8px);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:1002;
    }
    
    .pause-menu-content {
      background:var(--panel);
      padding:32px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.1);
      text-align:center;
      min-width:300px;
    }
    
    /* Controls */
    button{background:transparent;border:1px solid rgba(255,255,255,0.2);color:inherit;padding:8px 16px;border-radius:8px;cursor:pointer;transition:all 0.2s}
    button:hover{background:rgba(255,255,255,0.1);border-color:var(--accent)}
    select,input[type="range"]{background:transparent;color:inherit;border:1px solid rgba(255,255,255,0.2);border-radius:6px}
    select{padding:8px;width:100%}
    input[type="range"]{width:100%;margin:8px 0}
    input[type="checkbox"]{margin-left:8px}
    .small{font-size:12px;color:#9fb3d6}
    h3,h4{margin:0 0 12px 0;color:#fff}
    ul{margin:8px 0;padding-left:16px}
    li{margin:4px 0}
    
    /* Exit button */
    .exit-game {
      position:absolute;
      top:20px;
      right:20px;
      background:rgba(255,107,107,0.2);
      border:1px solid rgba(255,107,107,0.4);
      color:#ff6b6b;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      z-index:1001;
      font-size:12px;
    }
    
    .exit-game:hover {
      background:rgba(255,107,107,0.3);
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Pause Menu View -->
    <div v-if="gameState === 'menu'" class="pause-menu">
      <div class="game-preview">
        <canvas ref="previewCanvas" class="preview-canvas" width="800" height="500"></canvas>
        <div class="play-overlay">
          <h1 style="margin:0 0 16px 0;font-size:32px;background:linear-gradient(135deg,var(--accent),#60a5fa);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text">
            2D Space Shooter
          </h1>
          <button class="play-button" @click="startGame">
            ‚ñ∂ START GAME
          </button>
          <p class="small" style="margin-top:16px;opacity:0.7">Configure settings on the right, then press play!</p>
        </div>
      </div>

      <div class="settings-panel">
        <h3>Game Settings</h3>
        
        <label class="small">Difficulty</label>
        <select v-model="difficulty" style="margin:6px 0 16px 0">
          <option value="easy">Easy</option>
          <option value="normal">Normal</option>
          <option value="hard">Hard</option>
        </select>

        <label class="small">Enemy Spawn Rate</label>
        <input type="range" min="0.5" max="2.0" step="0.1" v-model.number="spawnMultiplier" />
        <div class="small" style="margin-bottom:16px">{{spawnMultiplier}}x</div>
        
        <div style="margin-bottom:16px">
          <label class="small">
            <input type="checkbox" v-model="showParticles" /> Enable Particles
          </label>
        </div>

        <div style="margin-top:24px;padding-top:16px;border-top:1px solid rgba(255,255,255,0.1)">
          <h4>How to Play</h4>
          <div class="small">
            <strong>Movement:</strong> WASD or Arrow Keys<br>
            <strong>Aim:</strong> Mouse<br>
            <strong>Shoot:</strong> Hold Left Click<br>
            <strong>Weapon Switch:</strong> Mouse Wheel<br>
            <strong>Pause:</strong> P or ESC<br>
          </div>
        </div>

        <div style="margin-top:16px;padding-top:16px;border-top:1px solid rgba(255,255,255,0.1)">
          <h4>Weapons</h4>
          <div class="small">
            <strong>Pistol:</strong> Balanced single shots<br>
            <strong>SMG:</strong> High fire rate, low damage<br>
            <strong>Shotgun:</strong> Spread shot, close range<br>
            <strong>Plasma:</strong> 3-round burst fire<br>
          </div>
        </div>
      </div>
    </div>

    <!-- Fullscreen Game View -->
    <div v-if="gameState === 'playing'" class="fullscreen-game">
      <canvas 
        ref="gameCanvas" 
        class="game-canvas" 
        :width="canvasWidth" 
        :height="canvasHeight"
        @mousemove="onMouseMove"
        @mousedown="onMouseDown"
        @mouseup="onMouseUp"
        @mouseleave="onMouseLeave"
        @wheel="onWheel"
        @contextmenu.prevent
      ></canvas>
      
      <!-- Game HUD -->
      <div class="game-hud">
        <div class="hud-row">
          <div class="score-display">{{score}}</div>
          <div class="small">Wave {{wave}} ‚Ä¢ {{enemies.length}} enemies ‚Ä¢ {{fps}} FPS</div>
        </div>
        <div class="hud-row">
          <div class="small" style="width:60px">Health:</div>
          <div class="health-bar">
            <div class="health-fill" :style="{
              width: Math.max(0, (player.hp/player.maxHp)*100) + '%',
              background: player.hp/player.maxHp < 0.35 ? 'linear-gradient(90deg, #ff6b6b, #ff8787)' : 'linear-gradient(90deg, var(--accent), #60a5fa)'
            }"></div>
          </div>
          <div class="small">{{Math.max(0, Math.round(player.hp))}}/{{player.maxHp}}</div>
        </div>
        <div class="hud-row">
          <div class="weapon-info">
            <strong>{{weapon.name}}</strong> ‚Ä¢ {{weapon.mode}}
          </div>
        </div>
      </div>
      
      <!-- Exit button -->
      <button class="exit-game" @click="exitToMenu">‚Üê EXIT</button>
      
      <!-- Pause overlay -->
      <div v-if="paused" class="pause-overlay">
      <!-- inside the pause overlay template (v-if="paused") -->
      <div class="pause-menu-content">
        <img class="gameover-img" src="assets/confetti.png" alt="Congrats" />
        <h2 style="margin:8px 0 12px 0" v-if="gameOver">{{ gameOverMessage }}</h2>
        <h2 style="margin:8px 0 12px 0" v-else>Game Paused</h2>

        <div class="gameover-stats" style="margin:12px 0 18px 0">
          <div class="small">Score: <strong>{{ score }}</strong></div>
          <div class="small">Wave reached: <strong>{{ wave }}</strong></div>
          <div class="small">Enemies killed: <strong>{{ enemiesKilled }}</strong></div>
          <div class="small">Bullets fired: <strong>{{ bulletsFired }}</strong></div>
          <div class="small">Accuracy: <strong>{{ bulletsFired ? Math.round((enemiesKilled / bulletsFired) * 100) : 0 }}%</strong></div>
          <div class="small">Run time: <strong>{{ formatMs(sessionTime) }}</strong></div>
        </div>

        <div style="display:flex;gap:12px;justify-content:center">
          <template v-if="!gameOver">
            <button @click="togglePause">Resume</button>
          </template>
          <button @click="restartGame">Restart</button>
          <button @click="exitToMenu">Exit to Menu</button>
        </div>
      </div>

      </div>
    </div>
  </div>

<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
  const { createApp, onMounted, onUnmounted, nextTick } = Vue;

  // Constants
  const CONSTANTS = {
    PLAYER_CONTACT_DAMAGE: 6,
    PLAYER_RECOIL: 40,
    ENEMY_CONTACT_DAMAGE: 9999,
    ENEMY_BULLET_DAMAGE: 12,
    FRICTION: 0.92,
    ACCELERATION: 1200,
    PARTICLE_LIFETIME: 800,
    MAX_BULLETS: 120,
    BURST_DELAY: 50,
  };
  const SPRITE_ANGLE_OFFSET = Math.PI / 2;

  createApp({
    data() {
      return {
        gameState: 'menu', // 'menu' or 'playing'
          startTime: 0,
          sessionTime: 0,       // ms
          enemiesKilled: 0,
          bulletsFired: 0,
        // Canvas dimensions
        canvasWidth: 1920,
        canvasHeight: 1080,
        
        // Game stats
        fps: 0,
        fpsCounter: 0,
        fpsLastTime: 0,
        score: 0,
        wave: 1,
        paused: false,
        gameOver: false, // NEW: distinguishes death vs regular pause
        
        // Settings
        difficulty: 'normal',
        spawnMultiplier: 1.0,
        showParticles: true,

        // Debug counts
        bulletsAlive: 0,
        enemiesSpawned: 0,

        // Game objects
        player: {
          x: 960, y: 540, r: 14, speed: 300, vx: 0, vy: 0,
          hp: 100, maxHp: 100, rotation: 0
        },
        enemies: [],
        bullets: [],
        particles: [],
        freeBullets: [],
        
        // Input
        mouse: { x: 960, y: 540, down: false },
        keys: {},

        // Weapons
        weapons: [
          { name: 'Pistol', mode: 'semi', fireRate: 200, bulletSpeed: 520, dmg: 18, spread: 0, auto: false },
          { name: 'SMG', mode: 'auto', fireRate: 70, bulletSpeed: 700, dmg: 8, spread: 6, auto: true },
          { name: 'Shotgun', mode: 'pump', fireRate: 600, bulletSpeed: 420, dmg: 9, spread: 18, pellets: 7, auto: false },
          { name: 'Plasma', mode: 'burst', fireRate: 120, bulletSpeed: 500, dmg: 12, spread: 8, burst: 3, auto: true }
        ],
        weaponIndex: 0,
        lastShotAt: 0,
        burstQueue: [],

        // Rendering
        ctx: null,
        previewCtx: null,
        lastTick: 0,
        animationId: null,
        
        // Assets
        assets: {},
        assetList: [
          { key: 'player', src: 'assets/player_ship.png' },
          { key: 'enemy_chaser', src: 'assets/enemy_chaser.png' },
          { key: 'enemy_shooter', src: 'assets/enemy_shooter.png' },
          { key: 'enemy_brute', src: 'assets/enemy_brute.png' },
          { key: 'enemy_runner', src: 'assets/enemy_runner.png' },
          { key: 'bullet_player', src: 'assets/bullet_yellow.png' },
          { key: 'bullet_enemy', src: 'assets/bullet_yellow.png' }
        ]
      }
    },
    
    computed: {
      gameOverMessage() {
      const w = Math.max(0, this.wave || 0);
      // playful messaging per round
      if (w <= 1) {
        return "Oof ‚Äî Round 1 already? Nice try... that was cute. üòÖ";
      }
      if (w === 2) {
        return "Round 2? Getting warmer ‚Äî nice try! üòâ";
      }
      if (w === 3) {
        return "Solid run ‚Äî Round 3! Not bad at all. üëç";
      }
      // w > 3
      return "Legendary ‚Äî you made it past 3! Nice job! üéâ";
    },

      weapon() { return this.weapons[this.weaponIndex] }
    },
    
    methods: {
      formatMs(ms) {
        if (!ms) return '0:00';
        const totalSec = Math.floor(ms / 1000);
        const mins = Math.floor(totalSec / 60);
        const secs = totalSec % 60;
        return `${mins}:${secs.toString().padStart(2,'0')}`;
      },

      startGame() {
        this.startTime = performance.now();
        this.sessionTime = 0;
        this.enemiesKilled = 0;
        this.bulletsFired = 0;
        this.gameState = 'playing';
        this.restartGame();
        this.requestPointerLock();
        nextTick(() => {
          this.initGameCanvas();
          // Preload assets then start the loop
          this.preloadAssets()
            .then(() => {
              this.startGameLoop();
            })
            .catch(() => {
              // Continue even if assets fail to load
              this.startGameLoop();
            });
        });
      },
      
      exitToMenu() {
        this.gameState = 'menu';
        this.paused = false;
        this.gameOver = false; // reset gameOver when leaving
        this.exitPointerLock();
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
      },
      
      requestPointerLock() {
        const canvas = this.$refs.gameCanvas;
        if (canvas && canvas.requestPointerLock) {
          canvas.requestPointerLock();
        }
      },
      
      exitPointerLock() {
        if (document.exitPointerLock) {
          document.exitPointerLock();
        }
      },
      
      initGameCanvas() {
        const canvas = this.$refs.gameCanvas;
        if (!canvas) return;
        
        this.ctx = canvas.getContext('2d');
        this.canvasWidth = window.innerWidth;
        this.canvasHeight = window.innerHeight;
        canvas.width = this.canvasWidth;
        canvas.height = this.canvasHeight;
        
        // Update player position to center of new canvas
        this.player.x = this.canvasWidth / 2;
        this.player.y = this.canvasHeight / 2;
      },
      
      initPreviewCanvas() {
        const canvas = this.$refs.previewCanvas;
        if (!canvas) return;
        
        this.previewCtx = canvas.getContext('2d');
        this.drawPreview();
      },
      
      drawPreview() {
        if (!this.previewCtx) return;
        
        const ctx = this.previewCtx;
        const w = 800, h = 500;
        
        ctx.clearRect(0, 0, w, h);
        
        // Draw some preview elements
        ctx.fillStyle = 'rgba(96,165,250,0.3)';
        ctx.beginPath();
        ctx.arc(w/2, h/2, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw some enemy previews
        ctx.fillStyle = 'rgba(251,113,133,0.4)';
        for (let i = 0; i < 5; i++) {
          const x = 100 + Math.random() * 600;
          const y = 100 + Math.random() * 300;
          ctx.beginPath();
          ctx.arc(x, y, 8, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.lineWidth = 1;
        for (let x = 0; x < w; x += 50) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
        }
        for (let y = 0; y < h; y += 50) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
          ctx.stroke();
        }
      },
      
      startGameLoop() {
        this.lastTick = performance.now();
        this.fpsLastTime = performance.now();
        this.gameLoop();
      },
      
      gameLoop() {
        if (this.gameState !== 'playing') return;
        
        const now = performance.now();
        const dt = Math.min(0.05, (now - this.lastTick) / 1000);
        this.lastTick = now;

        this.updateFPS();
        
        if (!this.paused) {
          this.update(dt);
        }
        
        this.draw();
        this.animationId = requestAnimationFrame(() => this.gameLoop());
      },
      
      togglePause() { 
        if (this.gameOver) return; // can't resume from a death state
        this.paused = !this.paused;
        if (this.paused) {
          this.exitPointerLock();
        } else {
          this.requestPointerLock();
        }
      },
      
      restartGame() {
        this.startTime = performance.now();
        this.sessionTime = 0;
        this.enemiesKilled = 0;
        this.bulletsFired = 0;
        this.score = 0;
        this.wave = 1;
        this.player.hp = this.player.maxHp;
        this.player.x = this.canvasWidth / 2;
        this.player.y = this.canvasHeight / 2;
        this.player.vx = 0;
        this.player.vy = 0;
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.burstQueue = [];
        this.enemiesSpawned = 0;
        this.paused = false;
        this.gameOver = false; // clear death flag on restart
        this.keys = {};
        this.mouse.down = false;
        this.initBulletPool();
        
        // Spawn initial enemies
        for (let i = 0; i < 3; i++) {
          this.spawnEnemy();
        }
      },

      initBulletPool() {
        this.bullets = [];
        this.freeBullets = [];
        for (let i = 0; i < CONSTANTS.MAX_BULLETS; i++) {
          const bullet = { alive: false, spriteKey: null };
          this.bullets.push(bullet);
          this.freeBullets.push(bullet);
        }
      },

      updateFPS() {
        this.fpsCounter++;
        const now = performance.now();
        if (now - this.fpsLastTime >= 1000) {
          this.fps = this.fpsCounter;
          this.fpsCounter = 0;
          this.fpsLastTime = now;
        }
      },

      update(dt) {
        const now = performance.now();
        
        this.processBurstQueue(now);
        this.updatePlayer(dt);
        this.handleShooting(now);
        this.updateBullets(dt);
        this.updateEnemies(dt, now);
        this.updateParticles(dt, now);
        this.spawnEnemiesIfNeeded();
        
        if (this.score > this.wave * 400) {
          this.wave++;
        }
        
        if (this.player.hp <= 0 && !this.gameOver) {
          // Player died: show game over pause overlay (no native confirm)
          this.gameOver = true;
          this.sessionTime = Math.max(0, performance.now() - this.startTime);
          this.paused = true;
          this.sessionTime = Math.max(0, performance.now() - this.startTime);

          this.exitPointerLock();
        }
      },

      updatePlayer(dt) {
        const acc = CONSTANTS.ACCELERATION;
        let ax = 0, ay = 0;
        if (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp']) ay -= 1;
        if (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown']) ay += 1;
        if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) ax -= 1;
        if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) ax += 1;
        
        const len = Math.hypot(ax, ay) || 1;
        this.player.vx += (ax / len) * acc * dt;
        this.player.vy += (ay / len) * acc * dt;

        this.player.vx *= CONSTANTS.FRICTION;
        this.player.vy *= CONSTANTS.FRICTION;
        const maxSpeed = this.player.speed;
        const vmag = Math.hypot(this.player.vx, this.player.vy);
        if (vmag > maxSpeed) {
          this.player.vx = (this.player.vx / vmag) * maxSpeed;
          this.player.vy = (this.player.vy / vmag) * maxSpeed;
        }

        this.player.x += this.player.vx * dt;
        this.player.y += this.player.vy * dt;

        this.player.x = Math.max(this.player.r, Math.min(this.canvasWidth - this.player.r, this.player.x));
        this.player.y = Math.max(this.player.r, Math.min(this.canvasHeight - this.player.r, this.player.y));
      },

      processBurstQueue(now) {
        for (let i = this.burstQueue.length - 1; i >= 0; i--) {
          const burst = this.burstQueue[i];
          if (now >= burst.nextShotTime && burst.remaining > 0) {
            const spread = (Math.random() - 0.5) * burst.spread * Math.PI / 180;
            this.shootAngle(burst.angle + spread);
            burst.remaining--;
            burst.nextShotTime = now + CONSTANTS.BURST_DELAY;
            
            if (burst.remaining <= 0) {
              this.burstQueue.splice(i, 1);
            }
          }
        }
      },

      handleShooting(now) {
        const weapon = this.weapon;
        if (this.mouse.down) {
          if (weapon.mode === 'semi' || weapon.mode === 'auto') {
            if (now - this.lastShotAt > weapon.fireRate) {
              this.shootOne();
              this.lastShotAt = now;
            }
          } else if (weapon.mode === 'burst') {
            if (now - this.lastShotAt > weapon.fireRate) {
              this.burstQueue.push({
                angle: this.getAimAngle(),
                spread: weapon.spread,
                remaining: weapon.burst || 3,
                nextShotTime: now
              });
              this.lastShotAt = now;
            }
          }
        }
      },

      shootOne() {
        const angle = this.getAimAngle();
        const w = this.weapon;
        if (w.name === 'Shotgun') {
          for (let i = 0; i < (w.pellets || 7); i++) {
            const spread = (Math.random() - 0.5) * w.spread * Math.PI / 180;
            this.shootAngle(angle + spread);
          }
        } else {
          this.shootAngle(angle + (Math.random() - 0.5) * (w.spread || 0) * Math.PI / 180);
        }
        
        this.spawnParticles(this.player.x + Math.cos(angle) * 20, this.player.y + Math.sin(angle) * 20, '#ffd166', 6);
        this.player.vx -= Math.cos(angle) * CONSTANTS.PLAYER_RECOIL;
        this.player.vy -= Math.sin(angle) * CONSTANTS.PLAYER_RECOIL;
      },

      shootAngle(angle) {
        const w = this.weapon;
        this.fireBullet(this.player.x + Math.cos(angle) * 20, this.player.y + Math.sin(angle) * 20, angle, w.bulletSpeed, w.dmg, 'player');
      },

      getAimAngle() {
        return Math.atan2(this.mouse.y - this.player.y, this.mouse.x - this.player.x);
      },

      fireBullet(x, y, angle, speed, dmg, owner = 'player') {
        if (this.freeBullets.length === 0) return null;
        
        const b = this.freeBullets.pop();
        b.alive = true;
        b.x = x;
        b.y = y;
        b.vx = Math.cos(angle) * speed;
        b.vy = Math.sin(angle) * speed;
        b.life = 3000;
        b.birth = performance.now();
        b.dmg = dmg;
        b.owner = owner;
        b.r = 4;
        b.angle = angle;
        b.rotation = angle;
        b.spriteKey = owner === 'player' ? 'bullet_player' : 'bullet_enemy';
        // count only player-fired bullets
        if (owner === 'player') {
          this.bulletsFired = (this.bulletsFired || 0) + 1;
        }

        return b;
      },

      returnBulletToPool(bullet) {
        bullet.alive = false;
        bullet.spriteKey = null;
        this.freeBullets.push(bullet);
      },

      updateBullets(dt) {
        this.bulletsAlive = 0;
        for (let i = this.bullets.length - 1; i >= 0; i--) {
          const b = this.bullets[i];
          if (!b.alive) continue;
          
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.life -= dt * 1000;
          
          if (b.life <= 0 || b.x < -40 || b.y < -40 || b.x > this.canvasWidth + 40 || b.y > this.canvasHeight + 40) {
            this.returnBulletToPool(b);
            continue;
          }
          this.bulletsAlive++;
        }
      },

      spawnEnemy(type = 'chaser') {
        const edge = Math.floor(Math.random() * 4);
        let x = 0, y = 0;
        const margin = 50;
        if (edge === 0) { x = -margin; y = Math.random() * this.canvasHeight }
        if (edge === 1) { x = this.canvasWidth + margin; y = Math.random() * this.canvasHeight }
        if (edge === 2) { x = Math.random() * this.canvasWidth; y = -margin }
        if (edge === 3) { x = Math.random() * this.canvasWidth; y = this.canvasHeight + margin }

        const baseHp = { chaser: 20, brute: 40, runner: 12, shooter: 18 }[type] || 18;
        const speed = { chaser: 65, brute: 35, runner: 150, shooter: 80 }[type] || 80;
        const difficultyMod = this.difficulty === 'hard' ? 1.2 : this.difficulty === 'easy' ? 0.85 : 1;
        
        const enemy = {
          id: Math.random().toString(36).slice(2),
          x, y, r: 12 + Math.random() * 8, vx: 0, vy: 0,
          type, rotation: 0,
          hp: baseHp * (1 + this.wave * 0.12 * difficultyMod),
          maxHp: baseHp, 
          speed: speed * (1 + this.wave * 0.03), 
          shootCooldown: 0,
          spriteKey: (type === 'shooter') ? 'enemy_shooter'
                    : (type === 'brute') ? 'enemy_brute'
                    : (type === 'runner') ? 'enemy_runner'
                    : 'enemy_chaser'
        };
        this.enemies.push(enemy);
        this.enemiesSpawned++;
      },

      updateEnemies(dt, now) {
        for (let i = this.enemies.length - 1; i >= 0; i--) {
          const e = this.enemies[i];
          const dx = this.player.x - e.x;
          const dy = this.player.y - e.y;
          const dist = Math.hypot(dx, dy) || 1;
          const nx = dx / dist, ny = dy / dist;

          if (e.type === 'runner') {
            const tangentX = -ny;
            const tangentY = nx;
            e.vx = (nx * 0.7 + tangentX * 0.3) * e.speed;
            e.vy = (ny * 0.7 + tangentY * 0.3) * e.speed;
          } else if (e.type === 'shooter') {
            e.shootCooldown -= dt * 1000;
            if (e.shootCooldown <= 0) {
              const leadTime = dist / 320;
              const futureX = this.player.x + this.player.vx * leadTime;
              const futureY = this.player.y + this.player.vy * leadTime;
              const ang = Math.atan2(futureY - e.y, futureX - e.x);
              
              this.fireBullet(e.x, e.y, ang, 320, 8, 'enemy');
              e.shootCooldown = 1200 + Math.random() * 600;
            }
            e.vx = nx * e.speed * 0.5;
            e.vy = ny * e.speed * 0.5;
          } else {
            e.vx = nx * e.speed;
            e.vy = ny * e.speed;
          }

          e.x += e.vx * dt;
          e.y += e.vy * dt;
          
          let target;
          if (Math.abs(e.vx) > 0.0001 || Math.abs(e.vy) > 0.0001) {
            target = Math.atan2(e.vy, e.vx);
          } else {
            target = Math.atan2(this.player.y - e.y, this.player.x - e.x);
          }

          const diff = ((target - e.rotation + Math.PI) % (2 * Math.PI)) - Math.PI;
          e.rotation += diff * 0.15;

          if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < e.r + this.player.r) {
            this.player.hp -= CONSTANTS.PLAYER_CONTACT_DAMAGE;
            this.spawnParticles(e.x, e.y, '#ff6b6b', 8);
            e.hp = 0;
          }

          let enemyHit = false;
          for (const b of this.bullets) {
            if (!b.alive || b.owner === 'enemy') continue;
            if (Math.hypot(b.x - e.x, b.y - e.y) < b.r + e.r) {
              e.hp -= b.dmg;
              this.returnBulletToPool(b);
              this.spawnParticles(b.x, b.y, '#ffd166', 6);
              if (e.hp <= 0) {
                enemyHit = true;
                break;
              }
            }
          }

          if (e.hp <= 0) {
            this.enemies.splice(i, 1);
            this.enemiesKilled = (this.enemiesKilled || 0) + 1;
            this.score += Math.floor(10 + e.maxHp * 1.5);
            this.spawnParticles(e.x, e.y, '#60a5fa', 18);
          }
        }

        for (const b of this.bullets) {
          if (!b.alive || b.owner !== 'enemy') continue;
          if (Math.hypot(b.x - this.player.x, b.y - this.player.y) < b.r + this.player.r) {
            this.returnBulletToPool(b);
            this.player.hp -= CONSTANTS.ENEMY_BULLET_DAMAGE;
            this.spawnParticles(b.x, b.y, '#ff6b6b', 10);
          }
        }
      },

      spawnParticles(x, y, color, count = 12) {
        if (!this.showParticles) return;
        for (let i = 0; i < count; i++) {
          this.particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 300,
            vy: (Math.random() - 0.5) * 300,
            life: 400 + Math.random() * 600,
            birth: performance.now(),
            r: 1 + Math.random() * 2,
            color
          });
        }
      },

      updateParticles(dt, now) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.98;
          p.vy *= 0.98;
          p.life -= dt * 1000;
          
          if (p.life <= 0 || p.x < -50 || p.y < -50 || p.x > this.canvasWidth + 50 || p.y > this.canvasHeight + 50) {
            this.particles.splice(i, 1);
          }
        }
      },

      spawnEnemiesIfNeeded() {
        if (this.enemies.length < 1 + Math.floor(this.wave * 2 * this.spawnMultiplier)) {
          const types = ['chaser', 'runner', 'shooter', 'brute'];
          const t = types[Math.floor(Math.random() * types.length)];
          this.spawnEnemy(t);
        }
      },

      draw() {
        if (!this.ctx) return;
        
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

        // Background grid
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.lineWidth = 1;
        for (let x = 0; x < this.canvasWidth; x += 64) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, this.canvasHeight);
          ctx.stroke();
        }
        for (let y = 0; y < this.canvasHeight; y += 64) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(this.canvasWidth, y);
          ctx.stroke();
        }
        ctx.restore();

        // Draw particles
        for (const p of this.particles) {
          ctx.globalAlpha = Math.max(0, Math.min(1, p.life / CONSTANTS.PARTICLE_LIFETIME));
          ctx.fillStyle = p.color || '#fff';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Draw bullets
        for (const b of this.bullets) {
          if (!b.alive) continue;

          const img = b.spriteKey ? this.assets[b.spriteKey] : null;
          const size = (b.r || 4) * 40;

          if (img) {
            const rot = (typeof b.rotation === 'number') ? b.rotation : Math.atan2(b.vy, b.vx);
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(rot + SPRITE_ANGLE_OFFSET);
            ctx.drawImage(img, -size/2, -size/2, size, size);
            ctx.restore();
          } else {
            ctx.beginPath();
            ctx.fillStyle = b.owner === 'player' ? '#ffd166' : '#ff6b6b';
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Draw enemies
        for (const e of this.enemies) {
          ctx.save();
          ctx.translate(e.x, e.y);
          ctx.rotate(e.rotation + SPRITE_ANGLE_OFFSET);

          if (e.spriteKey && this.assets[e.spriteKey]) {
            const img = this.assets[e.spriteKey];
            const size = e.r * 4;
            ctx.drawImage(img, -size/2, -size/2, size, size);
          } else {
            ctx.beginPath();
            ctx.fillStyle = '#fb7185';
            ctx.arc(0, 0, e.r, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();

          // HP bar
          const barWidth = e.r * 2;
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(e.x - barWidth/2, e.y - e.r - 12, barWidth, 4);
          ctx.fillStyle = '#60a5fa';
          ctx.fillRect(e.x - barWidth/2, e.y - e.r - 12, (e.hp / e.maxHp) * barWidth, 4);
        }

        // Player
        const ang = this.getAimAngle();
        
        // Shadow
        ctx.beginPath();
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.ellipse(this.player.x + 6, this.player.y + 10, this.player.r + 6, this.player.r + 3, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.assets.player) {
          const playerImg = this.assets.player;
          const desiredW = this.player.r * 5;
          const desiredH = this.player.r * 5;
          ctx.save();
          ctx.translate(this.player.x, this.player.y);
          // Use a smoothed visual rotation for the rendered sprite (keeps aiming immediate)
          const ROT_LERP = 0.25;
          let diff = ((ang - this.player.rotation + Math.PI) % (2 * Math.PI)) - Math.PI;
          this.player.rotation += diff * ROT_LERP;
          ctx.rotate(this.player.rotation + SPRITE_ANGLE_OFFSET);
          ctx.drawImage(playerImg, -desiredW/2, -desiredH/2, desiredW, desiredH);
          ctx.restore();
        } else {
          ctx.save();
          ctx.translate(this.player.x, this.player.y);
          const ROT_LERP = 0.25;
          let diff = ((ang - this.player.rotation + Math.PI) % (2 * Math.PI)) - Math.PI;
          this.player.rotation += diff * ROT_LERP;
          ctx.rotate(this.player.rotation + SPRITE_ANGLE_OFFSET);
          
          // Body
          ctx.beginPath();
          ctx.fillStyle = '#60a5fa';
          ctx.arc(0, 0, this.player.r, 0, Math.PI * 2);
          ctx.fill();
          
          // Gun
          ctx.fillStyle = '#0ea5a3';
          ctx.fillRect(8, -5, 18, 10);
          ctx.restore();
        }

        // Crosshair
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 2;
        ctx.moveTo(this.mouse.x - 12, this.mouse.y);
        ctx.lineTo(this.mouse.x + 12, this.mouse.y);
        ctx.moveTo(this.mouse.x, this.mouse.y - 12);
        ctx.lineTo(this.mouse.x, this.mouse.y + 12);
        ctx.stroke();
      },

      // Event handlers
      onMouseMove(e) {
        if (document.pointerLockElement) {
          // Use movement deltas when pointer is locked
          // clamp huge deltas to avoid jump when reacquiring pointer lock
          const mx = Math.max(-80, Math.min(80, e.movementX));
          const my = Math.max(-80, Math.min(80, e.movementY));
          this.mouse.x += mx;
          this.mouse.y += my;
          
          // Keep mouse within canvas bounds
          this.mouse.x = Math.max(0, Math.min(this.canvasWidth, this.mouse.x));
          this.mouse.y = Math.max(0, Math.min(this.canvasHeight, this.mouse.y));
        } else {
          // Fallback to regular mouse position
          const rect = this.$refs.gameCanvas.getBoundingClientRect();
          const scaleX = this.canvasWidth / rect.width;
          const scaleY = this.canvasHeight / rect.height;
          this.mouse.x = (e.clientX - rect.left) * scaleX;
          this.mouse.y = (e.clientY - rect.top) * scaleY;
        }
      },

      onMouseDown(e) {
        if (e.button === 0) {
          this.mouse.down = true;
          const weapon = this.weapon;
          if (weapon.mode === 'pump') {
            if (performance.now() - this.lastShotAt > 150) {
              this.shootOne();
              this.lastShotAt = performance.now();
            }
          }
        }
      },

      onMouseUp(e) {
        if (e.button === 0) {
          this.mouse.down = false;
        }
      },

      onMouseLeave() {
        this.mouse.down = false;
      },

      onWheel(e) {
        e.preventDefault();
        if (e.deltaY > 0) {
          this.weaponIndex = (this.weaponIndex + 1) % this.weapons.length;
        } else {
          this.weaponIndex = (this.weaponIndex - 1 + this.weapons.length) % this.weapons.length;
        }
      },

      onKeyDown(e) {
        this.keys[e.key] = true;
        if (e.key.toLowerCase() === 'p' || e.key === 'Escape') {
          e.preventDefault();
          this.togglePause();
        }
      },

      onKeyUp(e) {
        this.keys[e.key] = false;
      },

      onResize() {
        if (this.gameState === 'playing' && this.$refs.gameCanvas) {
          this.canvasWidth = window.innerWidth;
          this.canvasHeight = window.innerHeight;
          this.$refs.gameCanvas.width = this.canvasWidth;
          this.$refs.gameCanvas.height = this.canvasHeight;
        }
      },

      // Asset preloading
      preloadAssets() {
        const promises = this.assetList.map(a => {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
              this.assets[a.key] = img;
              resolve();
            };
            img.onerror = (e) => {
              console.warn('Failed to load', a.src, e);
              reject(e);
            };
            img.src = a.src;
          });
        });
        
        return Promise.allSettled(promises).then(results => {
          results.forEach((r, i) => {
            if (r.status === 'rejected') {
              console.warn('Asset failed:', this.assetList[i].src);
            }
          });
          return true;
        });
      }
    },

    mounted() {
      // Initialize preview
      nextTick(() => {
        this.initPreviewCanvas();
      });

      // Add global event listeners
      window.addEventListener('keydown', this.onKeyDown);
      window.addEventListener('keyup', this.onKeyUp);
      window.addEventListener('resize', this.onResize);
      
      // Handle pointer lock changes
      document.addEventListener('pointerlockchange', () => {
        if (!document.pointerLockElement && this.gameState === 'playing' && !this.paused) {
          this.paused = true;
        }
      });
    },

    beforeUnmount() {
      // Clean up
      window.removeEventListener('keydown', this.onKeyDown);
      window.removeEventListener('keyup', this.onKeyUp);
      window.removeEventListener('resize', this.onResize);
      
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      
      this.exitPointerLock();
    }
  }).mount('#app');
</script>

</body>
</html>
