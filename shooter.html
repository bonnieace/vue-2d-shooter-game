<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vue CDN — 2D Canvas Shooter (Fixed)</title>
  <style>
    :root{--bg:#0b1020;--panel:#0f1724;--accent:#4fd1c5;--danger:#ff6b6b}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#071023 0%, #071428 60%);color:#dbeafe}
    #app{display:flex;gap:16px;align-items:flex-start;height:100vh;padding:18px}
    .game-wrap{position:relative;flex:1;display:flex;justify-content:center;align-items:center}
    canvas{background:radial-gradient(ellipse at center,#071428 0%, #020612 60%);border-radius:12px;box-shadow:0 6px 30px rgba(2,6,15,0.7);max-width:100%;height:auto}
    .hud{position:absolute;left:18px;top:18px;background:rgba(7,10,20,0.6);backdrop-filter:blur(6px);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .controls{position:absolute;right:18px;top:18px;background:rgba(7,10,20,0.6);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .stat{font-size:13px;margin:4px 0}
    .bar{height:10px;background:rgba(255,255,255,0.06);border-radius:999px;overflow:hidden}
    .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#60a5fa)}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:6px 10px;border-radius:8px;cursor:pointer}
    footer{position:absolute;left:18px;bottom:18px;color:#93c5fd;font-size:12px}
    .small{font-size:12px;color:#9fb3d6}
  </style>
</head>
<body>
  <div id="app">
    <div class="game-wrap">
      <canvas id="gameCanvas" width="1024" height="640"></canvas>

      <div class="hud">
        <div style="display:flex;align-items:center;gap:10px">
          <div style="font-weight:700;font-size:16px">Score: {{score}}</div>
          <div class="small">Wave: {{wave}} | Enemies: {{enemies.length}} | FPS: {{fps}}</div>
        </div>

        <div class="stat" style="margin-top:8px">Health</div>
        <div class="bar" style="width:260px">
          <i :style="{
            width: Math.max(0, (player.hp/player.maxHp)*100) + '%', 
            background: 'linear-gradient(90deg,' + (player.hp/player.maxHp < 0.35 ? '#ff6b6b' : 'var(--accent)') + ', #60a5fa)'
          }"></i>
        </div>

        <div class="stat">Weapon: <strong>{{weapon.name}}</strong> — <span class="small">{{weapon.mode}}</span></div>
        <div style="margin-top:8px;display:flex;gap:8px">
          <button @click="togglePause">{{paused ? 'Resume' : 'Pause'}}</button>
          <button @click="restartGame">Restart</button>
        </div>
      </div>

      <div class="controls">
        <div class="small">Controls</div>
        <div class="small">WASD / Arrow keys — move</div>
        <div class="small">Mouse — aim</div>
        <div class="small">Left Click hold — fire</div>
        <div class="small">Mouse Wheel — switch weapon</div>
        <div class="small">P — pause</div>
      </div>

      <footer>Made with <strong>Vue CDN</strong> + Canvas • No external assets • Fixed Version</footer>
    </div>

    <div style="width:320px">
      <div style="background:var(--panel);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)">
        <h3 style="margin:0 0 8px 0">Game Settings</h3>
        <label class="small">Difficulty</label>
        <select v-model="difficulty" style="width:100%;margin:6px 0;padding:8px;border-radius:6px;background:transparent;color:inherit">
          <option value="easy">Easy</option>
          <option value="normal">Normal</option>
          <option value="hard">Hard</option>
        </select>

        <label class="small">Spawn density</label>
        <input type="range" min="0.5" max="2.0" step="0.1" v-model.number="spawnMultiplier" />
        <div class="small" style="margin-top:8px">Particles: <input type="checkbox" v-model="showParticles" /></div>

        <div style="margin-top:12px">
          <div class="small">Tips:</div>
          <ul class="small">
            <li>Use the wheel to try different weapons.</li>
            <li>Hold left mouse for automatic fire.</li>
            <li>Restart if you get stuck.</li>
          </ul>
        </div>
      </div>

      <div style="height:12px"></div>
      <div style="background:var(--panel);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)">
        <h4 style="margin:0 0 8px 0">Debug / Stats</h4>
        <div class="small">Bullets: {{bulletsAlive}}</div>
        <div class="small">Enemies Spawned: {{enemiesSpawned}}</div>
        <div class="small">Active Particles: {{particles.length}}</div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script>
    const { createApp, onMounted, reactive, onUnmounted } = Vue;

    // Constants
    const CONSTANTS = {
      PLAYER_CONTACT_DAMAGE: 6,
      PLAYER_RECOIL: 40,
      ENEMY_CONTACT_DAMAGE: 9999,
      ENEMY_BULLET_DAMAGE: 12,
      FRICTION: 0.92,
      ACCELERATION: 1200,
      PARTICLE_LIFETIME: 800,
      MAX_BULLETS: 120,
      BURST_DELAY: 50, // ms between burst shots
    };

    createApp({
      data() {
        return {
          fps: 0,
          fpsCounter: 0,
          fpsLastTime: 0,
          score: 0,
          wave: 1,
          paused: false,
          difficulty: 'normal',
          spawnMultiplier: 1.0,
          showParticles: true,

          // Debug counts
          bulletsAlive: 0,
          enemiesSpawned: 0,

          // Game internals
          player: {
            x: 512, y: 320, r: 14, speed: 260, vx: 0, vy: 0,
            hp: 100, maxHp: 100
          },
          enemies: [],
          bullets: [],
          particles: [],
          freeBullets: [], // Pool of available bullets
          mouse: { x: 512, y: 320, down: false },
          keys: {},

          weapons: [
            { name: 'Pistol', mode: 'semi', fireRate: 200, bulletSpeed: 520, dmg: 18, spread: 0, auto: false },
            { name: 'SMG', mode: 'auto', fireRate: 70, bulletSpeed: 700, dmg: 8, spread: 6, auto: true },
            { name: 'Shotgun', mode: 'pump', fireRate: 600, bulletSpeed: 420, dmg: 9, spread: 18, pellets: 7, auto: false },
            { name: 'Plasma', mode: 'burst', fireRate: 120, bulletSpeed: 500, dmg: 12, spread: 8, burst: 3, auto: true }
          ],
          weaponIndex: 0,
          lastShotAt: 0,
          burstQueue: [], // For proper burst timing

          // canvas
          ctx: null,
          cw: 1024, ch: 640,
          lastTick: performance.now(),
          tickDelta: 0,
          canvasElement: null,
          
          // Event listeners for cleanup
          eventListeners: []
        }
      },
      computed: {
        weapon() { return this.weapons[this.weaponIndex] }
      },
      methods: {
        togglePause() { this.paused = !this.paused },
        
        restartGame() {
          // FIXED: Reset all player properties including velocity
          this.score = 0;
          this.wave = 1;
          this.player.hp = this.player.maxHp;
          this.player.x = this.cw / 2;
          this.player.y = this.ch / 2;
          this.player.vx = 0; // FIXED: Reset velocity
          this.player.vy = 0; // FIXED: Reset velocity
          this.enemies = [];
          this.bullets = [];
          this.particles = [];
          this.burstQueue = [];
          this.enemiesSpawned = 0;
          this.paused = false;
          
          // FIXED: Clear all key states to prevent stuck movement
          this.keys = {};
          
          // FIXED: Reset mouse state
          this.mouse.down = false;
          
          // Reset bullet pool
          this.initBulletPool();
        },

        // FIXED: Improved bullet pool management
        initBulletPool() {
          this.bullets = [];
          this.freeBullets = [];
          for (let i = 0; i < CONSTANTS.MAX_BULLETS; i++) {
            const bullet = { alive: false };
            this.bullets.push(bullet);
            this.freeBullets.push(bullet);
          }
        },

        spawnEnemy(type = 'chaser') {
          const edge = Math.floor(Math.random() * 4);
          let x = 0, y = 0;
          if (edge === 0) { x = -30; y = Math.random() * this.ch }
          if (edge === 1) { x = this.cw + 30; y = Math.random() * this.ch }
          if (edge === 2) { x = Math.random() * this.cw; y = -30 }
          if (edge === 3) { x = Math.random() * this.cw; y = this.ch + 30 }

          const baseHp = { chaser: 20, brute: 40, runner: 12, shooter: 18 }[type] || 18;
          const speed = { chaser: 65, brute: 35, runner: 150, shooter: 80 }[type] || 80;

          const difficultyMod = this.difficulty === 'hard' ? 1.2 : this.difficulty === 'easy' ? 0.85 : 1;
          
          const enemy = {
            id: Math.random().toString(36).slice(2),
            x, y, r: 12 + Math.random() * 10, vx: 0, vy: 0,
            type, 
            hp: baseHp * (1 + this.wave * 0.12 * difficultyMod),
            maxHp: baseHp, 
            speed: speed * (1 + this.wave * 0.03), 
            shootCooldown: 0
          };
          this.enemies.push(enemy);
          this.enemiesSpawned++;
        },

        // FIXED: Use bullet pool efficiently
        fireBullet(x, y, angle, speed, dmg, owner = 'player') {
          if (this.freeBullets.length === 0) return null; // No bullets available
          
          const b = this.freeBullets.pop();
          b.alive = true;
          b.x = x;
          b.y = y;
          b.vx = Math.cos(angle) * speed;
          b.vy = Math.sin(angle) * speed;
          b.life = 2000;
          b.birth = performance.now();
          b.dmg = dmg;
          b.owner = owner;
          b.r = owner === 'player' ? 4 : 6;
          return b;
        },

        // FIXED: More efficient bullet cleanup
        returnBulletToPool(bullet) {
          bullet.alive = false;
          this.freeBullets.push(bullet);
        },

        spawnParticles(x, y, color, count = 12) {
          if (!this.showParticles) return;
          for (let i = 0; i < count; i++) {
            this.particles.push({
              x, y,
              vx: (Math.random() - 0.5) * 300,
              vy: (Math.random() - 0.5) * 300,
              life: 400 + Math.random() * 600,
              birth: performance.now(),
              r: 1 + Math.random() * 2,
              color
            });
          }
        },

        update(dt) {
          if (this.paused) return;
          const now = performance.now();

          // Update FPS counter
          this.updateFPS();

          // Process burst queue for proper timing
          this.processBurstQueue(now);

          // Player movement input
          const acc = CONSTANTS.ACCELERATION;
          let ax = 0, ay = 0;
          if (this.keys['w'] || this.keys['ArrowUp']) ay -= 1;
          if (this.keys['s'] || this.keys['ArrowDown']) ay += 1;
          if (this.keys['a'] || this.keys['ArrowLeft']) ax -= 1;
          if (this.keys['d'] || this.keys['ArrowRight']) ax += 1;
          
          const len = Math.hypot(ax, ay) || 1;
          this.player.vx += (ax / len) * acc * dt;
          this.player.vy += (ay / len) * acc * dt;

          // Friction / clamp
          this.player.vx *= CONSTANTS.FRICTION;
          this.player.vy *= CONSTANTS.FRICTION;
          const maxSpeed = this.player.speed;
          const vmag = Math.hypot(this.player.vx, this.player.vy);
          if (vmag > maxSpeed) {
            this.player.vx = (this.player.vx / vmag) * maxSpeed;
            this.player.vy = (this.player.vy / vmag) * maxSpeed;
          }

          this.player.x += this.player.vx * dt;
          this.player.y += this.player.vy * dt;

          // Keep inside
          this.player.x = Math.max(this.player.r, Math.min(this.cw - this.player.r, this.player.x));
          this.player.y = Math.max(this.player.r, Math.min(this.ch - this.player.r, this.player.y));

          // Shooting logic
          this.handleShooting(now);

          // Update bullets
          this.updateBullets(dt);

          // Update enemies
          this.updateEnemies(dt, now);

          // Update particles
          this.updateParticles(dt, now);

          // Spawn new enemies
          this.spawnEnemiesIfNeeded();

          // Increase difficulty
          if (this.score > this.wave * 400) {
            this.wave++;
          }

          // Death check
          if (this.player.hp <= 0) {
            this.paused = true;
            setTimeout(() => alert('You died! Score: ' + this.score), 100);
          }
        },

        // FIXED: FPS calculation
        updateFPS() {
          this.fpsCounter++;
          const now = performance.now();
          if (now - this.fpsLastTime >= 1000) {
            this.fps = this.fpsCounter;
            this.fpsCounter = 0;
            this.fpsLastTime = now;
          }
        },

        // FIXED: Proper burst weapon implementation
        processBurstQueue(now) {
          for (let i = this.burstQueue.length - 1; i >= 0; i--) {
            const burst = this.burstQueue[i];
            if (now >= burst.nextShotTime && burst.remaining > 0) {
              const spread = (Math.random() - 0.5) * burst.spread * Math.PI / 180;
              this.shootAngle(burst.angle + spread);
              burst.remaining--;
              burst.nextShotTime = now + CONSTANTS.BURST_DELAY;
              
              if (burst.remaining <= 0) {
                this.burstQueue.splice(i, 1);
              }
            }
          }
        },

        handleShooting(now) {
          const weapon = this.weapon;
          if (this.mouse.down) {
            if (weapon.mode === 'semi' || weapon.mode === 'auto') {
              if (now - this.lastShotAt > weapon.fireRate) {
                this.shootOne();
                this.lastShotAt = now;
              }
            } else if (weapon.mode === 'burst') {
              if (now - this.lastShotAt > weapon.fireRate) {
                // FIXED: Proper burst implementation
                this.burstQueue.push({
                  angle: this.getAimAngle(),
                  spread: weapon.spread,
                  remaining: weapon.burst || 3,
                  nextShotTime: now
                });
                this.lastShotAt = now;
              }
            }
          }
        },

        updateBullets(dt) {
          this.bulletsAlive = 0;
          for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            if (!b.alive) continue;
            
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            b.life -= dt * 1000;
            
            if (b.life <= 0 || b.x < -40 || b.y < -40 || b.x > this.cw + 40 || b.y > this.ch + 40) {
              this.returnBulletToPool(b);
              continue;
            }
            this.bulletsAlive++;
          }
        },

        updateEnemies(dt, now) {
          // FIXED: Process enemies backwards to avoid index issues when removing
          for (let i = this.enemies.length - 1; i >= 0; i--) {
            const e = this.enemies[i];
            const dx = this.player.x - e.x;
            const dy = this.player.y - e.y;
            const dist = Math.hypot(dx, dy) || 1;
            const nx = dx / dist, ny = dy / dist;

            // FIXED: Improved AI behaviors
            if (e.type === 'runner') {
              // Runner tries to flank with more intelligent movement
              const tangentX = -ny;
              const tangentY = nx;
              e.vx = (nx * 0.7 + tangentX * 0.3) * e.speed;
              e.vy = (ny * 0.7 + tangentY * 0.3) * e.speed;
            } else if (e.type === 'shooter') {
              // FIXED: Shooter leads target slightly
              e.shootCooldown -= dt * 1000;
              if (e.shootCooldown <= 0) {
                const leadTime = dist / 320; // Bullet speed
                const futureX = this.player.x + this.player.vx * leadTime;
                const futureY = this.player.y + this.player.vy * leadTime;
                const ang = Math.atan2(futureY - e.y, futureX - e.x);
                
                this.fireBullet(e.x, e.y, ang, 320, 8, 'enemy');
                e.shootCooldown = 1200 + Math.random() * 600;
              }
              // Shooter moves slower while aiming
              e.vx = nx * e.speed * 0.5;
              e.vy = ny * e.speed * 0.5;
            } else {
              // Basic chaser movement
              e.vx = nx * e.speed;
              e.vy = ny * e.speed;
            }

            e.x += e.vx * dt;
            e.y += e.vy * dt;

            // Collision with player
            if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < e.r + this.player.r) {
              this.player.hp -= CONSTANTS.PLAYER_CONTACT_DAMAGE;
              this.spawnParticles(e.x, e.y, '#ff6b6b', 8);
              e.hp = 0; // Mark for removal
            }

            // Bullet hits
            let enemyHit = false;
            for (const b of this.bullets) {
              if (!b.alive || b.owner === 'enemy') continue;
              if (Math.hypot(b.x - e.x, b.y - e.y) < b.r + e.r) {
                e.hp -= b.dmg;
                this.returnBulletToPool(b);
                this.spawnParticles(b.x, b.y, '#ffd166', 6);
                if (e.hp <= 0) {
                  enemyHit = true;
                  break;
                }
              }
            }

            // FIXED: Remove enemy properly
            if (e.hp <= 0) {
              this.enemies.splice(i, 1);
              this.score += Math.floor(10 + e.maxHp * 1.5);
              this.spawnParticles(e.x, e.y, '#60a5fa', 18);
            }
          }

          // Enemy bullets hitting player
          for (const b of this.bullets) {
            if (!b.alive || b.owner !== 'enemy') continue;
            if (Math.hypot(b.x - this.player.x, b.y - this.player.y) < b.r + this.player.r) {
              this.returnBulletToPool(b);
              this.player.hp -= CONSTANTS.ENEMY_BULLET_DAMAGE;
              this.spawnParticles(b.x, b.y, '#ff6b6b', 10);
            }
          }
        },

        // FIXED: More efficient particle management
        updateParticles(dt, now) {
          for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vx *= 0.98;
            p.vy *= 0.98;
            p.life -= dt * 1000;
            
            if (p.life <= 0 || p.x < -50 || p.y < -50 || p.x > this.cw + 50 || p.y > this.ch + 50) {
              this.particles.splice(i, 1);
            }
          }
        },

        spawnEnemiesIfNeeded() {
          if (this.enemies.length < 1 + Math.floor(this.wave * 2 * this.spawnMultiplier)) {
            const types = ['chaser', 'runner', 'shooter', 'brute'];
            const t = types[Math.floor(Math.random() * types.length)];
            this.spawnEnemy(t);
          }
        },

        shootOne() {
          const angle = this.getAimAngle();
          const w = this.weapon;
          if (w.name === 'Shotgun') {
            for (let i = 0; i < (w.pellets || 7); i++) {
              const spread = (Math.random() - 0.5) * w.spread * Math.PI / 180;
              this.shootAngle(angle + spread);
            }
          } else {
            this.shootAngle(angle + (Math.random() - 0.5) * (w.spread || 0) * Math.PI / 180);
          }
          
          // Muzzle particle & recoil
          this.spawnParticles(this.player.x + Math.cos(angle) * 20, this.player.y + Math.sin(angle) * 20, '#ffd166', 6);
          // Small recoil
          this.player.vx -= Math.cos(angle) * CONSTANTS.PLAYER_RECOIL;
          this.player.vy -= Math.sin(angle) * CONSTANTS.PLAYER_RECOIL;
        },

        shootAngle(angle) {
          const w = this.weapon;
          this.fireBullet(this.player.x + Math.cos(angle) * 20, this.player.y + Math.sin(angle) * 20, angle, w.bulletSpeed, w.dmg, 'player');
        },

        getAimAngle() {
          return Math.atan2(this.mouse.y - this.player.y, this.mouse.x - this.player.x);
        },

        gameLoop(now) {
          const dt = Math.min(0.05, (now - this.lastTick) / 1000);
          this.lastTick = now;

          if (!this.paused) {
            this.update(dt);
          }

          this.draw();
          requestAnimationFrame(this.gameLoop.bind(this));
        },

        draw() {
          const ctx = this.ctx;
          ctx.clearRect(0, 0, this.cw, this.ch);

          // Background grid (subtle)
          ctx.save();
          ctx.strokeStyle = 'rgba(255,255,255,0.02)';
          ctx.lineWidth = 1;
          for (let x = 0; x < this.cw; x += 64) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, this.ch);
            ctx.stroke();
          }
          for (let y = 0; y < this.ch; y += 64) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(this.cw, y);
            ctx.stroke();
          }
          ctx.restore();

          // Draw particles
          for (const p of this.particles) {
            ctx.globalAlpha = Math.max(0, Math.min(1, p.life / CONSTANTS.PARTICLE_LIFETIME));
            ctx.fillStyle = p.color || '#fff';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;

          // Draw bullets
          ctx.lineWidth = 1;
          for (const b of this.bullets) {
            if (!b.alive) continue;
            ctx.beginPath();
            ctx.fillStyle = b.owner === 'player' ? '#ffd166' : '#ff6b6b';
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
            ctx.fill();
          }

          // Draw enemies
          for (const e of this.enemies) {
            // Body
            ctx.beginPath();
            ctx.fillStyle = '#fb7185';
            ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
            ctx.fill();
            
            // HP bar
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fillRect(e.x - e.r, e.y - e.r - 8, e.r * 2, 4);
            ctx.fillStyle = '#60a5fa';
            ctx.fillRect(e.x - e.r, e.y - e.r - 8, (e.hp / e.maxHp) * e.r * 2, 4);
          }

          // Player
          const ang = this.getAimAngle();
          // Shadow
          ctx.beginPath();
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.ellipse(this.player.x + 6, this.player.y + 10, this.player.r + 6, this.player.r + 3, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.save();
          ctx.translate(this.player.x, this.player.y);
          ctx.rotate(ang);
          // Body
          ctx.beginPath();
          ctx.fillStyle = '#60a5fa';
          ctx.arc(0, 0, this.player.r, 0, Math.PI * 2);
          ctx.fill();
          // Gun
          ctx.fillStyle = '#0ea5a3';
          ctx.fillRect(8, -5, 18, 10);
          ctx.restore();

          // Crosshair
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(255,255,255,0.6)';
          ctx.lineWidth = 1;
          ctx.moveTo(this.mouse.x - 8, this.mouse.y);
          ctx.lineTo(this.mouse.x + 8, this.mouse.y);
          ctx.moveTo(this.mouse.x, this.mouse.y - 8);
          ctx.lineTo(this.mouse.x, this.mouse.y + 8);
          ctx.stroke();

          // HUD overlay in canvas
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(8, this.ch - 36, 300, 28);
          ctx.fillStyle = '#fff';
          ctx.font = '14px Inter, Arial';
          ctx.fillText('HP: ' + Math.max(0, Math.round(this.player.hp)) + '  |  Score: ' + this.score + '  |  FPS: ' + this.fps, 16, this.ch - 16);
        },

        // FIXED: Proper mouse coordinate calculation
        getMousePosition(e) {
          const rect = this.canvasElement.getBoundingClientRect();
          const scaleX = this.canvasElement.width / rect.width;
          const scaleY = this.canvasElement.height / rect.height;
          
          return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
          };
        },

        // FIXED: Clean up event listeners
        cleanup() {
          this.eventListeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
          });
          this.eventListeners = [];
        },

        addEventListenerWithCleanup(element, event, handler) {
          element.addEventListener(event, handler);
          this.eventListeners.push({ element, event, handler });
        }
      },

      mounted() {
        const canvas = document.getElementById('gameCanvas');
        this.canvasElement = canvas;
        this.ctx = canvas.getContext('2d');
        this.cw = canvas.width;
        this.ch = canvas.height;
        this.lastTick = performance.now();
        this.fpsLastTime = performance.now();

        // FIXED: Initialize bullet pool properly
        this.initBulletPool();

        // FIXED: Add event listeners with proper cleanup
        this.addEventListenerWithCleanup(canvas, 'mousemove', (e) => {
          const pos = this.getMousePosition(e);
          this.mouse.x = pos.x;
          this.mouse.y = pos.y;
        });

        this.addEventListenerWithCleanup(canvas, 'mousedown', (e) => {
          if (e.button === 0) {
            this.mouse.down = true;
            // For pump/shotgun, allow single shot on down
            const w = this.weapon;
            if (w.mode === 'pump') {
              if (performance.now() - this.lastShotAt > 150) {
                this.shootOne();
                this.lastShotAt = performance.now();
              }
            }
          }
        });

        this.addEventListenerWithCleanup(window, 'mouseup', (e) => {
          if (e.button === 0) this.mouse.down = false;
        });

        // FIXED: Prevent default on wheel and handle weapon switching properly
        this.addEventListenerWithCleanup(canvas, 'wheel', (e) => {
          e.preventDefault();
          if (e.deltaY > 0) {
            this.weaponIndex = (this.weaponIndex + 1) % this.weapons.length;
          } else {
            this.weaponIndex = (this.weaponIndex - 1 + this.weapons.length) % this.weapons.length;
          }
        });

        this.addEventListenerWithCleanup(window, 'keydown', (e) => {
          this.keys[e.key] = true;
          if (e.key.toLowerCase() === 'p') this.togglePause();
        });

        this.addEventListenerWithCleanup(window, 'keyup', (e) => {
          this.keys[e.key] = false;
        });

        // Handle mouse leaving canvas - stop firing
        this.addEventListenerWithCleanup(canvas, 'mouseleave', () => {
          this.mouse.down = false;
        });

        // Start game loop
        requestAnimationFrame(this.gameLoop.bind(this));

        // Initial spawns
        for (let i = 0; i < 3; i++) {
          this.spawnEnemy();
        }
      },

      // FIXED: Clean up when component is destroyed
      beforeUnmount() {
        this.cleanup();
      }
    }).mount('#app');
  </script>
</body>
</html>